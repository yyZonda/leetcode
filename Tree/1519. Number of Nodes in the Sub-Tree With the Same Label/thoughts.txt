这一题真的很恶心， 最开始的想法是先把题目的edges[][]排序，每个[][]都按照从小到大的顺序排列。排好序后，我们就可以利用递归DFS这棵虚拟的树
然后每次都返回一个HashMap<Character，Integer>， 在返回之前，我使用了一个int[]来记录相应位置的相同字母个数。本来可以完美解决问题。

但是！这个题目！他的edges竟然可以[[0,1],[0,2],[1,2]]把我惊呆了，就是不按照树形成的样子给数组。于是乎我的for循环就不能遍历所有的例子。我就想把for改为
每次从头遍历到尾，理论是可以行的。但是复杂度直接报表，O（n*n*n*n...），于是乎是不可能行的。再思考了一会，决定使用一个数据结构Node来保存每个点的children，
Node主要保存的是一个ArrayList<Integer>，把每个父亲节点的儿子节点都记录下来，这样递归遍历的时候遍历这个list就行了。再用一个HashMap<Integer,Node>来记录每个
点的Node。这样来代替每次都要遍历整个数组。

就这样通过了。

启示：
这题的启示主要有，我们可以用一个数据结构来记录儿子节点们，遍历只需遍历这个数据结构就行了。不用每次都从头再来的遍历。